\documentclass[letterpaper]{llncs}
\usepackage[letterpaper, margin=1.5in]{geometry}

\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{nccmath}
\usepackage{stmaryrd}
\usepackage{amssymb}
\usepackage{listings}


\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{url}

\makeatletter % allow us to mention @-commands
\def\arcr{\@arraycr}
\makeatother

\lstset{
    % identifierstyle=\color{violet},
    % textcolor=blue,
    % keywordstyle=\color{blue},
    keywordstyle=\text,
    basicstyle=\ttfamily,
    mathescape=true,
    showspaces=false,
    morekeywords={let, fix, in}
}
\usepackage[utf8]{inputenc}
% \usepackage[T1]{fontenc}


\title{Relational Types}
% \author{}
% \institute{}

\begin{document}
\maketitle


\section{Introduction}

\textbf{Context}. \newline
\textbf{Gap}. \newline
\textbf{Innovation}. \newline

\section{Overview}

\subsection{Language of types}
\textbf{Polymorphic}.  \newline
\textbf{Set-theoretic}. Union implies extrinsic/non-intrinsic. Implies Subtyping  \newline
\textbf{Relational}.  \newline

\subsection{Automation}
\textbf{Let-poly type-inference}. \newline
\textbf{Adjustments with union and intersection}. \newline
\textbf{Type checking two relational types}. \newline
\textbf{Path sensitivity}. \newline

\subsection{Examples}

\section{Related Techniques}

\textbf{HM type inference}.  \newline
\textbf{Logic programming}. Exemplified by Prolog. \newline
\textbf{Semantic subtyping}. Exemplified by XDuce and CDuce. complete subtyping.
% set theoretic notes: https://pnwamk.github.io/sst-tutorial/#%28part._sec~3asemantic-subtyping%29
% semantic subtyping: https://www.irif.fr/~gc/papers/semantic_subtyping.pdf
The terminology "semantic subtyping" vs "syntactic subtyping" are confusing terms. 
They actually refer 
to whether the semantics of types is determined indirectly by the semantics of another structure (as in semantics)
or whether the semantics of types is determined directly by the type structure (as in syntactic) 
Better terms would be "model-based" vs "proof-based".
A model-based system can be more complete but would require finding an inhabitations of the types.
That is the semantics of subtyping would depend on the semantics of typing (inhabitation of types).
This is analogous to SAT solving, proof synthesis more generally, model checking problem, and SMT.
If a type is model-based, not proof-based, then a proof must be found,
Since the "proof" is not part of the model-based subtyping statement, 
there is an infinite space to search to prove that the subtyping statement holds.
This leads to a more complete system, but a more difficult system to decide.
\newline
\textbf{Extrinsic typing}. The static behavior of a program is not necessarily specified/prescribed; 
it may be over-approximated from the program composition. 
All modern languages use a combination of static and dynamic type checking.
The term "dynamically typed" some times refers to a language that doesn't prescribe static meaning,
even if it uses both static and dynamic type checking. The term "extrinsic typing" is less ambiguous.
Exemplified by Typescript, which is unsound. Maybe not as lenient?  
\newline
\textbf{Refinement Types}. a restricted to intersection; implies intrinsic top\newline
\textbf{Predicate Subtyping}. An extension of refinement types exemplified by Liquid Types.
RLT starts with an invalid post-condition, then weakens return type to the (strongest) valid post-condition from outside in by expanding unions. 
RLT starts with an invalid pre-condition, then strengthens parameter type to a (weakest) valid pre-condition from inside out by adding intersections. 
Liquid types starts with an invalid post-condition, then uses iterative weakening by dropping conjunctions until a valid post-condition is reached.
\newline
\textbf{Abstraction Refinement}. Type unification over subtyping resembles abstraction refinement  
where solving for variables on different sides of the subtyping relation corresponds to
solving with the abstractor vs solving with the refiner.
\newline
\textbf{Craig interpolation}. extracting an inductive type with unions and intersections 
from a recursive program without needing to specify a predicate universe might be similar to
craig interpolation. \newline
\textbf{PDR}. exemplified by IC3. RLT infers abstract type for return type, 
then safely constrains the variables in previous step (fix's antecedent) 
to subtype the least fixed point.
This, in essence, propagates the type for the last step to the previous steps.
This is safe as antecedent is stronger than consequent at any step.
the technique in PDR for propagating negation of loss points might be related. 
 \newline 




\end{document}


