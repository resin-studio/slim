\documentclass[acmsmall]{acmart}
% \documentclass[letterpaper]{llncs}
% \usepackage[letterpaper, margin=1.5in]{geometry}


\usepackage{multicol}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{nccmath}
\usepackage{stmaryrd}
\usepackage{listings}
\usepackage[scaled]{beramono}
\usepackage[T1]{fontenc}

\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{url}

\makeatletter % allow us to mention @-commands
\def\arcr{\@arraycr}
\makeatother

\lstset{
    % identifierstyle=\color{violet},
    % textcolor=blue,
    % keywordstyle=\color{blue},
    % keywordstyle=\text,
    basicstyle=\ttfamily\small,
    % mathescape=true,
    % showspaces=false,
    % morekeywords={let, fix, in}
}



\title{Relational Type Inference}
% \author{}
% \date{}

\begin{document}

% \newcommand{\code}[1]{\texttt{\small #1}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\hastype}{\ \uparrow\ }
\newcommand{\I}{\hspace{4mm}}



\maketitle


\section{Introduction}

\paragraph{Context.} 
Automatically catching errors in programs is a hard enough problem
that many languages require users to provide simple specifications to limit that space of correctness.
Languages, such as Java and ML, are \textit{intrinsically typed}, 
requiring nearly all terms to be associated with some type specified by the user. 
The clever design of ML allows annotations to be fairly sparse by 
having types specified at constructor definitions and relying on type inference elsewhere.
For various reasons that aren't completely clear, intrinsically typed languages have lost favor,
and untyped or \textit{extrinsically typed} languages, 
such as Javascript/Typescript and Python, have surged in popularity. 

Despite the ever increasing use of untyped languages in production systems, 
the need to automatically verify precise and expressive properties of systems has never been greater.
To this end, researchers have extended the simple types found in Java and ML into 
\textit{refinement types}, \textit{predicate subtyping}, and \textit{dependent types}. 
Refinement types offer greater precision than simple types, but still rely on intrinsic type specifications.
Dependent types can express detailed relations, but may require users to provide proofs along with detailed annotations.
Predicate subtyping offers some of the expressivity of dependent types, but with the automatic subtyping of refinement types.
All of these techniques are based on intrinsic typing and therefore require users to provide additional annotations
beyond the runtime behavior of their programs.

\paragraph{Gap.} 
Unfortunately, since typing specifications are optional in extrinsically typed languages,
there are many untyped programs that cannot benefit from the intrinsically typed techniques,
not to mention techniques that require users to provide proofs.
For instance, the liquid type system \cite{} can verify and infer some relational properties, 
but it requires users to specify ML-style base types and a set of logical qualifiers to draw from.

While these intrinsic-based techniques could be useful if untyped programs were annotated,
the effort to manually annotate untyped programs is often enormous and error-prone, 
especially in cases where a programmer is using code written by third parties.
Thus, it is has become increasingly important to develop techniques 
that can automatically infer expressive types from untyped programs.

\paragraph{Innovation.} 
To overcome these limitations, we introduce a new system 
that automatically infers expressive properties from untyped functional programs. 
We introduce a new type language \textit{relational types} to represent these properties.

\section{Overview}

\subsection{Language of types}

\paragraph{Parametric types}
Universal types. Existential type. System F-style. Parameterization of types indexed by types (i.e. second order).

\paragraph{Combination types.}
One of the advantages of untyped programs is that they may be written in a flexible manner.
Subtyping is necessary safely reflect the flexibility of compositions in programs, without too many false failures.
Another main advantage of untyped programs is that users don't have to provide type specifications.
Thus, a general way of constructing types from compositions encountered in the the program is necessary.
Some compositions indicate that a type should strengthen, and some compositions indicate that a type should weaken.
To this end, the type language uses intersection and union combinators, 
whose semantics are degenerate versions of those in set-theory.

For instance, when inferring the type of a function, 
the system's goal is to infer the weakest valid parameter type and the strongest valid return type for a function definition.
It strengthens the parameter type with intersection and weakens the return type with union according to the function body,
to arrive at a valid type for the function.  

By contrast, the liquid type language relies on the less flexible tagged unions of ML datatypes, 
which is sufficient in its setting since those types are specified by the user. 
Likewise, it does not rely on union to weaken to a valid return type. 
Instead, it weakens to the strongest valid return type by dropping conjunctions from 
the return type's qualifiers until a valid return type is found.

\paragraph{Inductive types.} Similar to ML datatypes.

\paragraph{Constraint types.}
In addition to expressing the shapes of terms, the system should be able express relations between terms,
such as "a list has the length of some natural number".
Rather than using a distinct syntax for relational predicates, 
the type language treats relations as just another type thereby reusing machinery already 
available for types, such as existential types, union types, and inductive types.
Since parametric types are second order, constraining relations requires subtyping.
Thus, parametric types are extended with constraints in the form of subtyping.



\begin{figure*}[h]

    \begin{lstlisting}[mathescape=true]

        let trivial =
            path #hello => #world
            path #good => #morning in

        let repeat = path x => fix (path self =>
            path #zero => #nil
            path #succ n => #cons (x, self n)) in

        let fromList = fix (path self =>
            path #nil => $\hdots$
            path #cons (x, xs) => $\hdots$) in

        let fromNat = path x n => fromList (repeat x n)

        let fromUno = path (@uno = content) => $\hdots$ in
        let fromDos = path (@dos = content) => $\hdots$ in
        let fromBoth = path x => (fromUno x, fromDos, x)

        let lessOrEq = fix (path self =>
            path (#zero, _) => #true
            path (#succ x, #succ y) => self (x, y)
            path (#succ _, #zero) => #false) in

        let max = (path (x, y) => 
            if lessOrEq (x, y) then y else x) in

        $\hdots$


    \end{lstlisting}

\caption{Example program}
\label{fig:program}
\end{figure*}


\subsection{Type Inference}

We illustrate the syntax and semantics of programs and types with the example program shown in Fig. \ref{fig:program}.

\paragraph{Path typing.}
Consider the function \code{trivial} that completes an English phrase:

This program is defined by paths over hardcoded tags.
The system infers the type to be an intersection of implication types:
\begin{mathpar}
\\
  \inferrule {} {
    \Delta \cdot \Gamma
    \vdash 
    \code{trivial} : 
        \code{(?hello -> ?world) \& (?good -> ?morning)}
  }
\\
\end{mathpar}

\paragraph{Path selection.}

Suppose the function \code{trivial} is applied to a literal value \code{\#hello}. 
The system can discard the irrelevant clauses and infer the singleton type \code{?world}.
\begin{mathpar}
\\
    \inferrule {} {
        \Delta \cdot \Gamma
        \vdash 
        \code{trivial \#hello} :\ \code{?world} 
    }
\\
\end{mathpar}


\paragraph{Relational typing.} 
Consider the function \code{repeat} that takes a natural number and returns a list of that length. 
Without specifying any requirements besides the function definition, the system 
can infer the property that the resulting list has the length of the input number. 
\begin{mathpar}
\\
  \inferrule {
    nat = \code{induct N . ?zero | ?succ N} 
    \\\\
    nat\_list\ \alpha =  
    \left(
    \begin{array}[]{@{} l}
        \code{induct NL .} 
        \arcr
        \hspace{4mm} \code{?zero * ?nil |}
        \arcr
        \hspace{4mm} \code{\{?succ N * ?cons ($\alpha$ * L) with N * L <: NL\}}
    \end{array}
    \right)
  } {
    \Delta \cdot \Gamma
    \vdash 
    \code{repeat} : \code{forall X, N <:\ $nat$ . X -> N -> \{L with N * L <:\ $nat\_list$\ X\}} 
  }
\\
\end{mathpar}

\paragraph{Relational selection.} Suppose the function \code{repeat} is applied to the hardcoded number two, 
represented as \code{(\#succ \#succ \#zero)}. The system can infer the result to be a singleton type representing a single list,
much like how Prolog evaluates logic programs.
\begin{mathpar}
\\
  \inferrule {} {
    \Delta \cdot \Gamma
    \vdash 
    \code{repeat ()  (\#succ \#succ \#zero)}: \code{?cons (unit * ?cons (unit * ?nil))}
  }
\\
\end{mathpar}

Path selection and relational selection demonstrate that the declarative type language is expressive enough
to perform evaluation. However, this simply reproduces the effect of the dynamic semantics, 
albeit in a declarative style. For types to be useful in practice, they need to offer ways to
express properties with incomplete information.
The next examples illustrate how the system can compose abstract properties to infer useful properties,
which are not reproducible by dynamic semantics.


\paragraph{Factoring.} Suppose the function \code{fromList}, which expects a list, 
is applied to a list that's related to a natural number, as would be the result of \code{(repeat x n)},
illustrated in the body of \code{fromNat}.
The system must verify that the type of \code{(repeat x n)} is a subtype of the parameter type of \code{(fromList)}.
The argument type of \code{(repeat x n)} is a type projected from a relation with an abstract natural number,
since its arguments are not hardcoded.
This abstract type information cannot be handled by dynamic semantics. 
Despite these complexities, the the system is able to ensure that these abstract inferred types
can safely be composed, by factoring \code{($nat\_list\ \alpha$)} into the weaker pair \code{($nat$ * $list\ \alpha$)}.
Once factored out, the list type of the argument type's relation can be projected and unified with the parameter's list type. 
\begin{mathpar}
\\
  \inferrule {
    list\ \alpha = \code{induct L . ?nil | ?cons ($\alpha$ * L)} 
    \\\\
    \Delta \vdash \code{$nat\_list$\ X} \sqsubseteq \code{$nat$ * $list$\ X} 
    \\
    \Delta \vdash \code{$list$\ X} \sqsubseteq \code{$list$ Y} 
  } {
    \Delta \vdash \code{\{L with N * L <: $nat\_list$\ X\}} \sqsubseteq \code{$list$ Y} 
  }
\\
\end{mathpar}

\paragraph{Inductive subtyping.} 
Consider applying a function that expects a natural number to an argument whose type is an even natural number.
In order to verify that this application is allowed, the system must verify that an even number is 
a subtype of a natural number. The system can soundly verify this subtyping by relying on an induction hypothesis.
The induction hypothesis allows weakening the inductive component of the even type to the natural number type as it unrolls. 
\begin{mathpar}
\\
  \inferrule {
    \inferrule {
      even = \code{induct N . ?zero | ?succ ?succ N} 
      \\\\
      \Delta \vdash \code{(?zero | ?succ ?succ $nat$)} \sqsubseteq nat 
    } {
      \Delta, \code{$even$ <: $nat$}  \vdash \code{(?zero | ?succ ?succ $even$)} \sqsubseteq nat 
    }
  } {
    \Delta \vdash even \sqsubseteq nat 
  }
\\
\end{mathpar}

\paragraph{Relational subtyping.} Due to the precise relational types that the system infers, 
it may also be necessary to verify that a relation subtypes another relation, 
such as a list with an even length subtyping an list with a natural number length.
This situation is similar to inductive subtyping of simple types, but it is complicated
by relational constraints in the inductive relations, which must be added to the context.
\begin{mathpar}
\\
  \inferrule {
    \inferrule {
      even\_list\ \alpha =  
      \left(
      \begin{array}[]{@{} l}
          \code{induct EL .}
          \arcr
          \hspace{4mm} \code{?zero * ?nil |}
          \arcr
          \hspace{4mm} \code{\{?succ ?succ E * ?cons ?cons ($\alpha$ * L) with E * L <: EL\}}
      \end{array}
      \right)
      \\\\
      \Delta, \code{E * L <: $nat\_list$ unit} \vdash 
      \left(
      \begin{array}[]{@{} l}
        \code{?zero * ?nil |} 
        \arcr
        \code{?succ ?succ E * }
        \arcr
        \hspace{4mm}\code{?cons (unit * ?cons (unit * L))}
      \end{array}
      \right)
      \sqsubseteq nat\_list
    } {
      \left(
      \Delta, 
      \begin{array}[]{@{} l}
        \code{$even\_list$ unit <:$nat\_list$ unit},
        \arcr
        \code{E * L <: $even\_list$ unit}
      \end{array}
      \right)
      \vdash 
      \left(
      \begin{array}[]{@{} l}
        \code{?zero * ?nil |} 
        \arcr
        \code{?succ ?succ E * }
        \arcr
        \hspace{4mm}\code{?cons (unit * ?cons (unit * L))}
      \end{array}
      \right)
      \sqsubseteq nat\_list
      % \\\\
    }
  } {
    \Delta \vdash \code{($even\_list$ unit)} \sqsubseteq \code{($nat\_list$ unit)} 
  }
\\
\end{mathpar}



\paragraph{Refinement.}
Consider the function \code{fromBoth} that calls two functions on some variable of unknown value or type.  
The same variable is used as an argument to two separate functions that have different parameter types.
The type of the variable can be refined by intersecting both parameter types that it must satisfy.
\begin{mathpar}
\\
  \inferrule {} {
    \Delta \cdot \Gamma \vdash \code{fromBoth} : \code{(uno : X) \& (dos : Y) -> $\hdots$} 
  }
\\
\end{mathpar}

\paragraph{Path sensitivity.} Consider the function \code{max} that chooses the maximum of two natural numbers. 
The function must satisfy the property that the result is greater or equal to each of the inputs. 
The system can infer this property by relying on multiple type inference mechanisms, including
relational typing, path selection, refinement, and a special form of refinement that refines a type
by specializing relations it belongs to. The \emph{if-then-else} expression is merely sugar for applying
a function with a \emph{true} path and \emph{false} path to a boolean expression. 
Note that the variables are used in both the condition and the bodies of the if-then-else expression.
To infer a precise type for the if-then-else expression, the types of the variables need to be refined according to 
each path's expected type, but without leaking the refinement outside of that path. 
That is, the refinements must be local or path sensitive.
Moreover, there must be enough paths of the applied function to handle all 
the possible values of the argument.
\begin{mathpar}
\\
  \inferrule {
    leq\_decide =  
    \left(
    \begin{array}[]{@{} l}
        \code{induct LED .} 
        \arcr
        \hspace{4mm} \code{\{?zero * \_ * ?true\} |}
        \arcr
        \hspace{4mm} \code{\{?succ X * ?succ Y * B  with X * Y * B <: LED\} |}
        \arcr
        \hspace{4mm} \code{\{?succ \_ * ?zero * ?false\}}
    \end{array}
    \right)
    \\\\
    max\_spec =  
    \left(
    \begin{array}[]{@{} l}
        \code{X * Y -> Y \& \{Z with (X * Z * ?true) <: $leq\_decide$\} |}
        \arcr
        \code{X * Y -> X \& \{Z with (Z * Y * ?false) <: $leq\_decide$\}}
    \end{array}
    \right)
  } {
    \Delta \cdot \Gamma \vdash \code{max} : max\_spec 
  }
\\
\end{mathpar}


% \paragraph{List bounds.}
% \paragraph{Generalization.} This is motivated by applying the same function to multiple arguments of varying types.
% \paragraph{Object oriented.}  

\section{Language}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Syntax %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[h]
\[
  \begin{array}{l @{} l}
    e 
    &{} ::=
    \begin{array}[t]{@{} l}
      \code{$x$}
      \ |\ 
      \code{()}
      \ |\ 
      \code{\#$l$ $e$} 
      \ |\ 
      \widebar{\code{@$l$ = $e$}}
      \ |\ 
      \widebar{\code{path $m$ => $e$}} 
      \ |\ 
      \code{$e$.$l$}
      \ |\ 
      \code{$e$ $e$} 
      \ |\ 
      \code{fix $e$}
      \ |\ 
      \code{let $x$ : $\tau$ = $e$ in $e$}
    \end{array}
    \\
    m 
    &{} ::=
    \begin{array}[t]{@{} l}
      \code{$x$}
      \ |\ 
      \code{()}
      \ |\ 
      \code{\#$l$ $e$} 
      \ |\ 
      \widebar{\code{@$l$ = $e$}}
    \end{array}
    \\
    \tau
    &{} ::=
    \begin{array}[t]{@{} l}
      \code{unit} 
      \ |\ 
      \code{$\alpha$} 
      \ |\ 
      \code{?$l$ $\tau$} 
      \ |\ 
      \code{$l$ : $\tau$} 
      \ |\ 
      \code{$\tau$ -> $\tau$} 
      \ |\ 
      (\code{$\tau$ | $\tau$})
      \ |\ 
      \code{$\tau$ \& $\tau$}
      \ |\ 
      \\
      \code{\{$\widebar{\alpha}$ // $\tau$ with $\tau$ <: $\tau$\}}
      \ |\ 
      \code{[$\alpha$ <: $\tau$] $\tau$}
      \ |\ 
      \code{induct $\alpha$ . $\tau$}
    \end{array}
  \end{array}
\]

\caption{Syntax}
\end{figure*}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Typing 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subtyping 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NOTE: need rule to lift object constraint to meta constraint
%%      T1 <: T2  in Delta
%%  ---------------------------
%%    Delta |- T1 subtypes T2 


\section{Analysis}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Internal Structures %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[h]
\[
\begin{array}{l @{} l}
  \mathbb{D} \owns \Delta 
  &{} ::=
  \begin{array}[t]{@{} l}
    \emptyset 
    \ |\ 
    \Delta, \code{$\tau$ <: $\tau$}
  \end{array}
  \\
  \mathbb{G} \owns \Gamma 
  &{} ::=
  \begin{array}[t]{@{} l}
    \emptyset 
    \ |\ 
    \Gamma, \code{$x$ : $\tau$}
  \end{array}
\end{array}
\]

\caption{Internal Structures}
\end{figure*}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Type inference 

\begin{figure*}[h]


\begin{flalign*}
  &\boxed{\text{infer}\ \Delta\ \tau_{l}\ \tau_{r} = \widebar{(\Delta, \tau)}}&
\end{flalign*}

\[
\begin{array}[t]{@{} l}
    \text{infer}\ \Delta\ \Gamma\ e\ \tau = 
    \\
    \I \text{match}\ e

    \\

    %% variable 
    \I \text{case } \code{()} \Rightarrow [(\Delta, \code{unit})] 
    \\
    \I \text{case } \code{$x$} \Rightarrow 
    \\
    \I\I \text{match } (\code{$x$<:\_} \in \Gamma)
    \\
    \I\I \text{case } (\text{some } \tau) \Rightarrow [(\Delta, \tau)] 
    \\
    \I\I \text{case } \text{none} \Rightarrow []

    \\

    %% tag 
    \I \text{case } \code{\#$l$ $e$}  \Rightarrow  
    \\
    \I\I \text{for } (\Delta, \tau) \leftarrow (\text{infer } \Delta\ \Gamma\ e) 
     \\
    \I\I\I [(\Delta, \code{?$l$ $\tau$})] 

    \\

    %% record
    \I \text{case } \widebar{\code{@$l$ $e$}}  \Rightarrow  
    \\
    \I\I solution \leftarrow [(\Delta, \top)]
    \\
    \I\I \text{for } (\code{@$l_i$ $e_i$}) \leftarrow \widebar{\code{@$l$ $e$}} 
    \\
    \I\I\I solution \leftarrow (
    \\
    \I\I\I\I \text{for } (\Delta, \tau) \leftarrow solution 
    \\
    \I\I\I\I \text{for } (\Delta, \tau_i) \leftarrow (\text{infer } \Delta\ \Gamma\ e_i) 
    \\
    \I\I\I\I\I [(\Delta, \code{($l_i$:$\tau_i$) \& $\tau$})])
    \\
    \I\I solution

    \\

    %% function
    \I \text{case } (\widebar{\code{path $m$ => $e$}})  \Rightarrow  
    \\
    \I\I solution \leftarrow [(\Delta, \top)]
    \\
    \I\I \text{for } (\code{path $m_i$ => $e_i$}) \leftarrow (\widebar{\code{path $m$ => $e$}}) 
    \\
    \I\I\I \text{for } x \leftarrow (\text{freevars } m_i)
    \\
    \I\I\I\I \tau_m \leftarrow \text{fresh} 
    \\
    \I\I\I\I \Gamma \leftarrow \Gamma, \code{$x$<:$\tau_m$}
    \\
    \I\I\I solution \leftarrow
    \\
    \I\I\I\I \text{for } (\Delta, \tau) \leftarrow solution 
    \\
    \I\I\I\I \text{for } (\Delta, \tau_{mi}) \leftarrow (\text{infer } \Delta\ \Gamma\ m_i) 
    \\
    \I\I\I\I \text{for } (\Delta, \tau_{ei}) \leftarrow (\text{infer } \Delta\ \Gamma\ e_i) 
    \\
    \I\I\I\I\I [(\Delta, \code{($\tau_{mi}$->$\tau_{ei}$) \& $\tau$})]
    \\
    \I\I solution

    \\

    %% projection 
    \I \text{case } \code{$e$.$l$} \Rightarrow  
    \\
    \I\I \tau_l \leftarrow \text{fresh}
    \\
    \I\I \text{for } (\Delta, \tau_e) \leftarrow (\text{infer } \Delta\ \Gamma\ e)
    \\
    \I\I \text{for } \Delta \leftarrow (\text{unify } \Delta\ \tau_e\ (\code{$l$:$\tau_l$}))
    \\
    \I\I\I [(\Delta, \tau_l)]
\end{array}
\begin{array}[t]{@{} l}
    %% application 
    \I \text{case } (\code{$e_f$ $e_a$}) \Rightarrow  
    \\
    \I\I \tau_{res} \leftarrow \text{fresh}
    \\
    \I\I \widebar{(\Delta_s, \tau_s)} \leftarrow (\text{infer } \Gamma\ e_a)
    \\
    \I\I \widebar{(\Delta_w, \tau_w)} \leftarrow
    \\
    \I\I\I \text{for } (\Delta, \tau_a) \leftarrow \widebar{(\Delta_s, \tau_s)}
    \\
    \I\I\I \text{for } (\Delta, \tau_f) \leftarrow (\text{infer } \Delta\ \Gamma\ e_f)
    \\
    \I\I\I \text{for } \Delta \leftarrow (\text{unify } \Delta\ \tau_f\ (\code{$\tau_a$->$\tau_{ret}$}))
    \\
    \I\I\I\I [(\Delta, \tau_a)]
    \\
    \I\I \text{if } (\text{safe } \widebar{(\Delta_s, \tau_s)}\ \widebar{(\Delta_w, \tau_w)} ) \text{ then }
    \\
    \I\I\I \text{for } (\Delta, \_) \leftarrow \widebar{(\Delta_w, \tau_w)}
    \\
    \I\I\I\I [(\Delta, \tau_{res})]
    \\
    \I\I \text{else } [] 

    \\

    %% let-binding 
    \I \text{case } (\code{let $x$ : $\tau_p$ = $e_a$ in $e_b$}) \Rightarrow  
    \\
    \I\I \widebar{x_t} \leftarrow \text{allvars}
    \\
    \I\I \widebar{(\Delta_s, \tau_s)} \leftarrow (\text{infer } \Gamma\ e_a)
    \\
    \I\I \widebar{(\Delta_w, \tau_w)} \leftarrow [(\Delta, \tau_p)]
    \\
    \I\I \text{if } (\text{safe } \widebar{(\Delta_s, \tau_s)}\ \widebar{(\Delta_w, \tau_w)} ) \text{ then }
    \\
    \I\I\I \text{for } (\Delta, \tau_a) \leftarrow (\text{infer } \Delta\ \Gamma\ e_a)
    \\
    \I\I\I \text{for } \Delta \leftarrow (\text{unify } \Delta\ \tau_a\ \tau_p)
    \\
    \I\I\I\I \tau_{gen} \leftarrow \text{generalize } \widebar{x_t}\ \Delta\ \tau_a
    \\
    \I\I\I\I (\text{infer } \Delta\ (\Gamma,\code{$x$:$\tau_{gen}$})\ e_b)
    \\
    \I\I \text{else } [] 

    \\

    %% let-binding 
    \I \text{case } (\code{fix $e$}) \Rightarrow  
    \\
    \I\I \widebar{\alpha_{stale}} \leftarrow \text{staleTVs}
    \\
    \I\I \alpha_{IH} \leftarrow \text{freshTV}; \alpha_{IC} \leftarrow \text{freshTV}
    \\
    \I\I \text{for } (\Delta, \tau) \leftarrow (\text{infer}\ \Delta\ \Gamma\ e) 
    \\
    \I\I \text{for } \Delta \leftarrow (\text{unify}\ \Delta\ \tau\ (\code{$\alpha_{IH}$->$\alpha_{IC}$})) 
    \\
    \I\I\I \tau_{IH} \leftarrow \text{sub}\ \Delta\ \alpha_{IH}  
    \\
    \I\I\I \tau_{IC} \leftarrow \text{sub}\ \Delta\ \alpha_{IC}
    \\
    \I\I\I \tau_{par} \leftarrow \text{makeParam}\ \widebar{\alpha_{stale}}\ \tau_{IH}\ \tau_{IC}
    \\
    \I\I\I \tau_{rel} \leftarrow \text{makeRelation}\ \widebar{\alpha_{stale}}\ \tau_{IH}\ \tau_{IC}
    \\
    \I\I\I \alpha \leftarrow \text{freshTV}; \beta \leftarrow \text{freshTV}
    \\
    \I\I\I \tau_{sol} \leftarrow
    \\
    \I\I\I\I \code{[$\alpha$<:$\tau_{par}$] $\alpha$->\{$\beta$ with ($\alpha$*$\beta$)<:$\tau_{rel}$\}}
    \\
    \I\I\I [(\Delta, \tau_{sol})]





\end{array}
\]


%%%%%%%%%%%%%%%%%%%%%%
%% NOTE: need each rule to have a vector environments, representing possible worlds 
%% declarative inference rules can't capture the important aspects of refinement 
%% need functional rules 
%%%%%%%%%%%%%%%%%%%%%%
% \begin{flalign*}
%   &\boxed{\Delta \cdot \Gamma \Vdash e \hastype \tau}&
% \end{flalign*}

% \begin{mathpar}
%   \inferrule { 
%     (\code{$x$ : $\tau$}) \in \Gamma
%   } {
%     \Delta \cdot \Gamma
%     \Vdash x \hastype \tau
%   } 

%   \inferrule { 
%   } {
%     \Delta \cdot \Gamma 
%     \Vdash \code{()} \hastype \code{unit}
%   } 

%   \inferrule { 
%     \Delta \cdot \Gamma \Vdash e \hastype \tau
%   } {
%     \Delta \cdot \Gamma 
%     \Vdash (\code{\#$l$ $e$}) \hastype (\code{?$l$ $\tau$})
%   } 

%   \inferrule { 
%     \bigwedge\nolimits_i\ \Delta \cdot \Gamma \Vdash e_i \hastype \tau_i
%   } {
%     \Delta \cdot \Gamma
%     \Vdash 
%     \widebar{\code{@$l_i$ = $e_i$}}^i 
%     \hastype
%     \code{\&}_i\ (\code{$l_i$ : $\tau_i$})
%   } 

%   \inferrule { 
%     \bigwedge\nolimits_i\ \Delta \cdot \Gamma;\Gamma' \Vdash m_i \hastype \tau'_i
%     \\
%     \bigwedge\nolimits_i\ \Delta \cdot \Gamma;\Gamma' \Vdash e_i \hastype \tau''_i
%   } {
%     \Delta \cdot \Gamma
%     \Vdash
%     \widebar{\code{path $m_i$ => $e_i$}}^i 
%     \hastype 
%     \code{\&}_i\ (\code{$\tau_i'$ -> $\tau_i''$}) 
%   } 

%   \inferrule { 
%     \Delta \cdot \Gamma \Vdash e \hastype \tau
%     \\
%     \Delta \Vdash \tau \sqsubseteq (\code{$l$ : $\alpha$})
%   } {
%     \Delta \cdot \Gamma \Vdash \code{$e$.$l$} \hastype \alpha
%   } 

%   \inferrule* [left=App] { 
%     \Delta \cdot \Gamma \Vdash e_1 \hastype \tau_1
%     \\\\
%     \\\\
%     \bigwedge\nolimits_{\Delta'}  \Delta;\Delta' \cdot \Gamma \Vdash e_2 \hastype \tau_2
%     \longrightarrow
%     \Delta \Vdash \tau_1 \sqsubseteq (\code{$\tau_2$ -> $\alpha$})
%     \\\\
%     \\\\
%     \bigwedge\nolimits_{\Delta'}  
%     \Delta \Vdash \tau_1 \sqsubseteq (\code{$\tau_2$ -> $\alpha$})
%     \longrightarrow
%     \Delta;\Delta' \cdot \Gamma \Vdash e_2 \hastype \tau_2
%     \\
%     % \text{union}\ \vec{\Delta_0}\ \tau_2 \sqsubseteq \text{union}\ \vec{\Delta}\ \tau_2
%     % \\\\
%     % \vdash \vec{\Delta} = \vec{\Delta_1} \times \vec{\Delta_2} \times \vec{\Delta_3}
%   } {
%     \Delta \cdot \Gamma
%     \Vdash (\code{$e_1$ $e_2$}) \hastype \alpha
%   } 

%   \inferrule { 
%     % TODO: define/update generalize  
%     \Delta \cdot \Gamma \Vdash e_1 \hastype \tau_1
%     \\
%     \tau_1' = \text{generalize}\ \Delta\ \tau_1
%     \\
%     \Delta \cdot (\Gamma,\ \code{x : $\tau_1'$}) \Vdash e_2 \hastype \tau_2
%     \\
%   } {
%     \Delta \cdot \Gamma 
%     \Vdash 
%     (\code{let $x$ : $\tau_1$ = $e_1$ in $e_2$}) \hastype \tau_2
%   } 

%   \inferrule { 
%     % TODO: update inference using implication with inductive type  
%     \Delta \cdot \Gamma \Vdash e \hastype \tau \rightarrow \tau'
%     \\
%     \tau' = 
%   } {
%     \Delta;\Delta' \cdot \Gamma  
%     \Vdash \code{fix $e$} \hastype (\text{extract}\ \tau\ \tau_i') 
%   } 
% \end{mathpar}
\caption{Type inference.
  \newline
  Input: $\Delta \cdot \Gamma \Vdash e : \_ $. The input is the type variable environment, typing environment, and the expression.
  \newline
  Output: $\Delta \cdot \_ \Vdash \_ : \tau $. The output is the type variable environment and the result type.
}
\end{figure*}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
%% Subtype unification: standard rules 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\begin{figure*}[h]
\begin{flalign*}
  &\boxed{\text{unify}\ \Delta\ \tau_{l}\ \tau_{r} = \widebar{\Delta}}&
\end{flalign*}
\[
\begin{array}[t]{@{} l}
    \text{unify}\ \Delta\ \tau_{l}\ \tau_{r} = 
    \arcr
    \hspace{4mm}\begin{array}[t]{@{} l}
      \text{match}\ \tau_{l}, \tau_{r}\ \text{with} 
      \arcr
      \cdot\ \hdots, \hdots  \Rightarrow \hdots
    \end{array}
\end{array}
\]


% \begin{flalign*}
%   &\boxed{\Delta \cdot \Omega \Vdash \tau \sqsubseteq \tau}&
% \end{flalign*}
% \begin{mathpar}
%   \inferrule {
%   } {
%     \Delta \cdot \Omega \Vdash \text{unit} \sqsubseteq \text{unit}
%   }

%   \inferrule {
%     \Delta \cdot \Omega \Vdash \tau_1 \sqsubseteq \tau_2
%   } {
%     \Delta \cdot \Omega \Vdash l*\tau_1 \sqsubseteq l*\tau_2
%   }

%   \inferrule {
%     \Delta \cdot \Omega \Vdash \tau_1 \sqsubseteq \tau_2
%   } {
%     \Delta \cdot \Omega \Vdash l:\tau_1 \sqsubseteq l:\tau_2
%   }

%   \inferrule {
%     \Delta \cdot \Omega \Vdash \tau_3 \sqsubseteq \tau_1
%     \\
%     \Delta \cdot \Omega \Vdash \tau_2 \sqsubseteq \tau_4
%   } {
%     \Delta \cdot 
%       \Omega \Vdash \tau_1\rightarrow\tau_2 \sqsubseteq \tau_3\rightarrow\tau_4	
%   }
%   \\
%   \inferrule {
%     \Delta \cdot \Omega \Vdash \tau_1 \sqsubseteq \tau_3
%     \\
%     \Delta \cdot \Omega \Vdash \tau_2 \sqsubseteq \tau_3
%   } {
%     \Delta \cdot \Omega \Vdash \tau_1 \sqcup \tau_2 \sqsubseteq \tau_3
%   }

%   \inferrule {
%     \Delta \cdot \Omega \Vdash \tau_1 \sqsubseteq \tau_2
%   } {
%     \Delta \cdot \Omega \Vdash \tau_1 \sqsubseteq \tau_2 \sqcup \tau_3
%   }

%   \inferrule {
%     \Delta \cdot \Omega \Vdash \tau_1 \sqsubseteq \tau_3
%   } {
%     \Delta \cdot \Omega \Vdash \tau_1 \sqsubseteq \tau_2 \sqcup \tau_3
%   }

%   \inferrule {
%     \Delta \cdot \Omega \Vdash \tau_1 \sqsubseteq \tau_2
%     \\
%     \Delta \cdot \Omega \Vdash \tau_1 \sqsubseteq \tau_3
%   } {
%     \Delta \cdot \Omega \Vdash \tau_1 \sqsubseteq \tau_2 \sqcap \tau_3
%   }

%   \inferrule {
%     \Delta \cdot \Omega \Vdash \tau_1 \sqsubseteq \tau_3
%   } {
%     \Delta \cdot \Omega \Vdash \tau_1 \sqcap \tau_2 \sqsubseteq \tau_3
%   }

%   \inferrule {
%     \Delta \cdot \Omega \Vdash \tau_2 \sqsubseteq \tau_3
%   } {
%     \Delta \cdot \Omega \Vdash \tau_1 \sqcap \tau_2 \sqsubseteq \tau_3
%   }
% \end{mathpar}
\caption{Subtype unification: standard rules.
  \newline
  Input: $\Delta \cdot \Omega \Vdash \tau \sqsubseteq \tau$. The input is the type variable environment, the complex environment, the subtype, and the supertype. 
  \newline
  Output: $\Delta \cdot \_ \Vdash \_ \sqsubseteq \_$. The output is the type variable environment. 
}
\end{figure*}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subtype unification: extended rules
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure*}[h]
\begin{flalign*}
  &\boxed{\Delta \cdot \Omega \Vdash \tau \sqsubseteq \tau}&
\end{flalign*}

% \begin{mathpar}
%   \inferrule {
%     \bigwedge\nolimits_i\ \alpha_i \not\in (\text{dom}\ \Delta)
%     \\
%     \Delta;\Delta' \cdot \Omega \Vdash \tau_1 \sqsubseteq \tau_2
%     \\
%     \Delta;\Delta' \cdot \Omega \Vdash \tau_3 \sqsubseteq \tau_4
%   } {
%     \Delta \cdot \Omega \Vdash \tau_1 \sqsubseteq 
%       \left< \exists \widebar{\alpha_i}^i\ .\ \tau_2\ |\ \tau_3 \sqsubseteq \tau_4 \right>
%   }

%   \inferrule {
%     \bigwedge\nolimits_i\ \alpha_i \not\in (\text{dom}\ \Delta)
%     \\
%     \text{complex}\ \Delta\ \tau_3 = k
%     \\
%     \Delta;\Delta' \cdot \Omega, \downarrow k \mapsto \tau_4 \Vdash \tau_1 \sqsubseteq \tau_2
%     \\
%     \bigwedge\nolimits_i\ \alpha_i \not\in (\text{dom}\ \Delta')
%   } {
%     \Delta \cdot \Omega \Vdash 
%       \left< \exists \widebar{\alpha_i}^i\ .\ \tau_1\ |\ \tau_3 \sqsubseteq \tau_4 \right> \sqsubseteq
%       \tau_2
%   }

%   \inferrule {
%     % TODO: update with union solution for constraint  
%     \bigwedge\nolimits_i\ \alpha_i \not\in (\text{dom}\ \Delta)
%     \\
%     \text{complex}\ \Delta\ \tau_3 \neq k
%     \\
%     \Delta;\Delta' \cdot \Omega \Vdash \tau_3 \sqsubseteq \tau_4
%     \\
%     \Delta;\Delta' \cdot \Omega \Vdash \tau_1 \sqsubseteq \tau_2
%     \\
%     \bigwedge\nolimits_i\ \alpha_i \not\in (\text{dom}\ \Delta')
%   } {
%     \Delta \cdot \Omega \Vdash 
%       \left< \exists \widebar{\alpha_i}^i\ .\ \tau_1\ |\ \tau_3 \sqsubseteq \tau_4 \right> \sqsubseteq
%       \tau_2
%   }

%   \inferrule {
%     \bigwedge\nolimits_i\ \alpha_i \not\in (\text{dom}\ \Delta)
%     \\
%     \Delta;\Delta' \cdot \Omega \Vdash \tau_1 \sqsubseteq \tau_2
%     \\
%     \Delta;\Delta' \cdot \Omega \Vdash \tau_3 \sqsubseteq \tau_4
%   } {
%     \Delta \cdot \Omega \Vdash  
%       \left< \forall \widebar{\alpha_i}^i\ .\ \tau_1\ |\ \tau_3 \sqsubseteq \tau_4 \right>
%       \sqsubseteq \tau_2
%   }
%   \\
%   \inferrule {
%     \bigwedge\nolimits_i\ \alpha_i \not\in (\text{dom}\ \Delta)
%     \\
%     \text{complex}\ \Delta\ \tau_4 = k
%     \\
%     \Delta;\Delta' \cdot \Omega, \uparrow k \mapsto \tau_3 \Vdash \tau_1 \sqsubseteq \tau_2
%     \\
%     \bigwedge\nolimits_i\ \alpha_i \not\in (\text{dom}\ \Delta')
%   } {
%     \Delta \cdot \Omega \Vdash 
%       \tau_1
%       \sqsubseteq
%       \left< \forall \widebar{\alpha_i}^i\ .\ \tau_2\ |\ \tau_3 \sqsubseteq \tau_4 \right>
%   }
%   \\
%   \inferrule {
%     % TODO: update with intersecting of solution to constraint  
%     \bigwedge\nolimits_i\ \alpha_i \not\in (\text{dom}\ \Delta)
%     \\
%     \text{complex}\ \Delta\ \tau_4 \neq k
%     \\
%     \Delta;\Delta' \cdot \Omega \Vdash \tau_3 \sqsubseteq \tau_4
%     \\
%     \Delta;\Delta' \cdot \Omega \Vdash \tau_1 \sqsubseteq \tau_2
%     \\
%     \bigwedge\nolimits_i\ \alpha_i \not\in (\text{dom}\ \Delta')
%   } {
%     \Delta \cdot \Omega \Vdash 
%       \tau_1
%       \sqsubseteq
%       \left< \forall \widebar{\alpha_i}^i\ .\ \tau_2\ |\ \tau_3 \sqsubseteq \tau_4 \right>
%   }
%   \\
%   \\
%   %%%%%%%%%%%%%%%%%%%%%%%
%   \inferrule {
%     \alpha \not\in (\text{dom}\ \Delta)
%   } {
%     (\Delta, \alpha \mapsto \text{rolldn}\ \alpha\ \tau) \cdot \Omega 
%     \Vdash \alpha \sqsubseteq \tau
%   }

%   \inferrule {
%     (\Delta\ \alpha) = \tau'
%     \\
%     \Delta \cdot \Omega \Vdash \tau' \sqsubseteq \tau
%   } {
%     \Delta \cdot \Omega \Vdash \alpha \sqsubseteq \tau
%   }

%   \inferrule {
%     (\Delta\ \alpha) = \tau'
%     \\
%     \neg (\Delta;\Delta' \cdot \Omega \Vdash \tau' \sqsubseteq \tau)
%   } {
%     (\Delta, \alpha \mapsto \text{rolldn}\ \alpha\ (\tau' \sqcap \tau)) 
%     \cdot \Omega 
%     \Vdash \alpha \sqsubseteq \tau
%   }

%   \inferrule {
%     \alpha \not\in (\text{dom}\ \Delta)
%   } {
%     (\Delta, \alpha \mapsto \text{rollup}\ \alpha\ \tau) 
%     \cdot \Omega \Vdash \tau \sqsubseteq \alpha
%   }

%   \inferrule {
%     (\Delta\ \alpha) = \tau'
%     \\
%     \Delta \cdot \Omega \Vdash \tau \sqsubseteq \tau'
%   } {
%     \Delta \cdot \Omega \Vdash \tau \sqsubseteq \alpha
%   }

%   \inferrule {
%     (\Delta\ \alpha) = \tau'
%     \\
%     \neg (\Delta;\Delta' \cdot \Omega \Vdash \tau \sqsubseteq \tau')
%   } {
%     (\Delta, \alpha \mapsto \text{rollup}\ \alpha\ (\tau' \sqcup \tau))
%     \cdot \Omega \Vdash \tau \sqsubseteq \alpha
%   }
%   %%%%%%%%%%%%%%%%%%
%   \\
%   \\
%   \inferrule {
%     % TODO: modify to match code; no need for rhs to be inductive  
%     \Delta \cdot \Omega \Vdash 
%       \tau_1[\alpha_1\mapsto\mu\alpha_2.\tau_2] % by induction hypothesis
%       \sqsubseteq 
%       \tau_2[\alpha_2\mapsto\mu\alpha_2.\tau_2]
%   } {
%     \Delta \cdot \Omega \Vdash \mu \alpha_1 . \tau_1 \sqsubseteq \mu \alpha_2 . \tau_2
%   }
%   \\
%   \inferrule {
%     \text{complex}\ \tau_1 = k 
%     \\
%     \Delta \cdot \Omega \Vdash (\Omega\ \downarrow\ k) \sqsubseteq \mu \alpha . \tau_2
%   } {
%     \Delta \cdot \Omega \Vdash \tau_1 \sqsubseteq \mu \alpha . \tau_2
%   }
%   \\
%   \inferrule {
%     \text{complex}\ \tau_1 \neq k 
%     \\
%     \text{wellfounded}\ \alpha\ \tau_2
%     \\
%     \Delta \cdot \Omega \Vdash \tau_1 \sqsubseteq \tau_2[\alpha \mapsto \mu \alpha . \tau_2]
%   } {
%     \Delta \cdot \Omega \Vdash \tau_1 \sqsubseteq \mu \alpha . \tau_2
%   }
%   \\
%   \inferrule {
%     \Delta \cdot \Omega \Vdash 
%         \tau_1[\alpha_1\mapsto\nu\alpha_1.\tau_1] 
%         \sqsubseteq 
%         \tau_2[\alpha_2\mapsto\nu\alpha_1.\tau_1]
%         % by co-induction hypothesis
%   } {
%     \Delta \cdot \Omega \Vdash \nu \alpha_1 . \tau_1 \sqsubseteq \nu \alpha_2 . \tau_2	
%   }
%   \\
%   \inferrule {
%     \text{complex}\ \tau_2 = k 
%     \\
%     \Delta \cdot \Omega \Vdash \nu \alpha . \tau_1 \sqsubseteq (\Omega\ \uparrow\ k) 
%   } {
%     \Delta \cdot \Omega \Vdash \nu \alpha . \tau_1 \sqsubseteq \tau_2
%   }
%   % \\
%   % \inferrule {
%   %   \text{wellroofed}\ \alpha\ \tau_1
%   %   \\
%   %   \text{complex}\ \tau_2 \neq k 
%   %   \\
%   %   \Delta \cdot \Omega \Vdash \tau_1[\alpha \mapsto \nu \alpha . \tau_1] \sqsubseteq \tau_2
%   % } {
%   %   \Delta \cdot \Omega \Vdash \nu \alpha_1 . \tau_1 \sqsubseteq \tau_2
%   % }
%   \\
%   \inferrule {
%     \text{complex}\ \tau_2 \neq k 
%     \\
%     \text{rewrite}\ \nu \alpha . \tau_1 = \tau_1'
%     \\
%     \Delta \cdot \Omega \Vdash \tau_1' \sqsubseteq \tau_2
%   } {
%     \Delta \cdot \Omega \Vdash \nu \alpha . \tau_1 \sqsubseteq \tau_2
%   }
% \end{mathpar}
\caption{Subtype unification: extended rules}
\end{figure*}




\section{Properties}

\section{Related work}

\paragraph{Hindley-Milner type inference}
Exemplified by ML.

\paragraph{Logic programming.}
Exemplified by Prolog. 

Similar: both have backchaining. 

Different: RLT is fully declarative, lacks negations, but has implication. 

Different: RLT allows comparing inductive relations via subtyping. 

\paragraph{Semantic subtyping.} 
Exemplified by XDuce and CDuce. complete subtyping.

Similar: set-like combinators: union and intersection.

Different: RLT uses rigid syntactic rules; incomplete subtyping.

% set theoretic notes: https://pnwamk.github.io/sst-tutorial/#%28part._sec~3asemantic-subtyping%29
% semantic subtyping: https://www.irif.fr/~gc/papers/semantic_subtyping.pdf
The terminology "semantic subtyping" vs "syntactic subtyping" are confusing terms. 
"semantics subtyping" means the semantics of types is determined indirectly by the semantics of another structure.
"syntactic subtyping" means the semantics of types is determined directly by the type structure

In my opinion, better terms would be "model-based" vs "proof-based".
A model-based system can be more complete but requires proving absence of inhabitation of the types.
That is, the semantics of subtyping would depend on the semantics of inhabitation of types.
This is related to SAT solving, proof synthesis, model checking, and SMT.
If a type is model-based, not proof-based, then a proof must be found.
Since the "proof" is not part of the model-based subtyping statement, 
there is an infinite space to search to prove that the subtyping statement holds.
This leads to a more complete system, but a more difficult system to decide.

\paragraph{Extrinsic typing.}
Exemplified by Typescript, which is unsound. Maybe not as lenient?  
The static behavior of a program is not necessarily specified/prescribed; 
it may be over-approximated from the program composition. 
Intrinsic vs extrinsic is orthogonal to static vs dynamic, although static and dynamic are often used to mean the former.
All modern languages use a combination of static and dynamic type checking.
The term "dynamically typed" some times refers to a language that doesn't prescribe static meaning,
even if it uses both static and dynamic type checking. The term "extrinsic typing" is less ambiguous.

\paragraph{Refinement Types.}
Exemplified by Refinement ML. Base types with intersections and subtyping.

\paragraph{Predicate Subtyping.}
Exemplified by Liquid Types. An extension of refinement types.

Similar: both use type inference to infer expressive relational properties. 

Different: RLT starts with an invalid post-condition, then weakens return type to a valid post-condition from outside in by expanding unions.

Different: RLT starts with an invalid pre-condition, then strengthens parameter type to a valid pre-condition from inside out by adding intersections.

Different: Liquid types starts with an invalid post-condition, then uses iterative weakening by dropping conjunctions until a valid post-condition is reached.


\paragraph{Abstraction Refinement.} 
Similar: type unification over subtyping resembles abstraction refinement  
where solving for variables and failing on different sides of the subtyping relation corresponds to
solving with the abstractor vs solving with the refiner.

\paragraph{Craig interpolation.} 
Similar: extracting an inductive type with unions and intersections 
from a recursive program without needing to specify a predicate universe might be similar to
craig interpolation.

\paragraph{PDR.}
exemplified by IC3. 

Similar: RLT infers abstract type for return type, 
then safely constrains the variables in previous step (fix's antecedent) 
to subtype the least fixed point.
This lazily propagates the type for the last step to the previous steps.
This is safe as antecedent is stronger than consequent at any step.
Seems similar to the notion in PDR of propagating negation of loss points to previous steps. 

Different: RLT isn't cartesian

\end{document}


