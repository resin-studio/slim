\documentclass[letterpaper]{llncs}
\usepackage[letterpaper, margin=1.5in]{geometry}

\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{nccmath}
\usepackage{stmaryrd}
\usepackage{amssymb}
\usepackage{listings}


\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{url}

\makeatletter % allow us to mention @-commands
\def\arcr{\@arraycr}
\makeatother

\lstset{
    % identifierstyle=\color{violet},
    % textcolor=blue,
    % keywordstyle=\color{blue},
    keywordstyle=\text,
    basicstyle=\ttfamily,
    mathescape=true,
    showspaces=false,
    morekeywords={let, fix, in}
}
\usepackage[utf8]{inputenc}
% \usepackage[T1]{fontenc}


\title{Relational Types}
% \author{}
% \institute{}

\begin{document}
\maketitle


\section{Introduction}

\paragraph{Context.} 
Ensuring correctness of programs in general is a hard enough problem
that many languages rely on annotations to limit that space of correctness.
Languages, such as Java and ML, are \textit{intrinsically typed}, requiring
all terms to be associated with some type specified by the user. 
The clever design of ML allows annotations to be fairly sparse by 
requiring types to be specified at constructor definitions and relying on type inference elsewhere.
For various reasons that aren't completely clear, intrinsically typed languages have lost favor,
and untyped or \textit{extrinsically typed} languages, 
such as Javascript/Typescript and Python, have surged in popularity. 

Despite the ever increasing use of untyped languages in production systems, 
the need to automatically verify precise and expressive properties of systems has never been greater.
To this end, researchers have extended the simple types found in Java and ML into 
refinement types, predicate subtyping, and dependent types. 
Refinement types offer greater precision than simple types, but still rely on intrinsic type specifications.
Dependent types can express detailed relations, but may require users to provide proofs.
Predicate subtyping offers some of the expressivity of dependent types, 
but with the automatic subtyping of refinement types.
All of these techniques are based on intrinsic typing and therefore require users to provide some amount of specification.

\paragraph{Gap.} 
Unfortunately, since typing specifications are optional in extrinsically typed languages,
there are many untyped programs that cannot benefit from the intrinsically typed techniques,
not to mention techniques that require users to provide proofs.
For instance, Liquid Types can verify and infer simple relational properties, but requires
users to specify ML-style base types and a universe of predicates to draw from.
The effort manually annotate untyped programs would be enormous in many cases.
Therefore, it is necessary to develop techniques that can automatically infer expressive types
from untyped programs.

\paragraph{Innovation.} 
To overcome these limitations, we present a new system that automatically infers expressive properties 
from untyped functional programs. 
We design a new type language \textit{relational types} to represent these properties.
The key contribution is the ability to infer expressive types from untyped programs
without loss of important features from intrinsically typed languages, such as let-polymormism and path-sensitivity. 
\newline

\section{Overview}

\subsection{Language of types}
\textbf{Polymorphic}.  \newline
\textbf{Set-theoretic}. Union implies extrinsic/non-intrinsic. Implies Subtyping  \newline
\textbf{Relational}.  \newline

\subsection{Automation}
\textbf{Let-poly type-inference}. \newline
\textbf{Adjustments with union and intersection}. \newline
\textbf{Type checking two relational types}. \newline
\textbf{Path sensitivity}. \newline

\subsection{Examples}

\section{Related Techniques}

\textbf{HM type inference}.  \newline
\textbf{Logic programming}. Exemplified by Prolog. \newline
\textbf{Semantic subtyping}. Exemplified by XDuce and CDuce. complete subtyping.
% set theoretic notes: https://pnwamk.github.io/sst-tutorial/#%28part._sec~3asemantic-subtyping%29
% semantic subtyping: https://www.irif.fr/~gc/papers/semantic_subtyping.pdf
The terminology "semantic subtyping" vs "syntactic subtyping" are confusing terms. 
They actually refer 
to whether the semantics of types is determined indirectly by the semantics of another structure (as in semantics)
or whether the semantics of types is determined directly by the type structure (as in syntactic) 
Better terms would be "model-based" vs "proof-based".
A model-based system can be more complete but would require finding an inhabitations of the types.
That is the semantics of subtyping would depend on the semantics of typing (inhabitation of types).
This is analogous to SAT solving, proof synthesis more generally, model checking problem, and SMT.
If a type is model-based, not proof-based, then a proof must be found,
Since the "proof" is not part of the model-based subtyping statement, 
there is an infinite space to search to prove that the subtyping statement holds.
This leads to a more complete system, but a more difficult system to decide.
\newline
\textbf{Extrinsic typing}. The static behavior of a program is not necessarily specified/prescribed; 
it may be over-approximated from the program composition. 
All modern languages use a combination of static and dynamic type checking.
The term "dynamically typed" some times refers to a language that doesn't prescribe static meaning,
even if it uses both static and dynamic type checking. The term "extrinsic typing" is less ambiguous.
Exemplified by Typescript, which is unsound. Maybe not as lenient?  
\newline
\textbf{Refinement Types}. a restricted to intersection; implies intrinsic top\newline
\textbf{Predicate Subtyping}. An extension of refinement types exemplified by Liquid Types.
RLT starts with an invalid post-condition, then weakens return type to the (strongest) valid post-condition from outside in by expanding unions. 
RLT starts with an invalid pre-condition, then strengthens parameter type to a (weakest) valid pre-condition from inside out by adding intersections. 
Liquid types starts with an invalid post-condition, then uses iterative weakening by dropping conjunctions until a valid post-condition is reached.
\newline
\textbf{Abstraction Refinement}. Type unification over subtyping resembles abstraction refinement  
where solving for variables on different sides of the subtyping relation corresponds to
solving with the abstractor vs solving with the refiner.
\newline
\textbf{Craig interpolation}. extracting an inductive type with unions and intersections 
from a recursive program without needing to specify a predicate universe might be similar to
craig interpolation. \newline
\textbf{PDR}. exemplified by IC3. RLT infers abstract type for return type, 
then safely constrains the variables in previous step (fix's antecedent) 
to subtype the least fixed point.
This, in essence, propagates the type for the last step to the previous steps.
This is safe as antecedent is stronger than consequent at any step.
the technique in PDR for propagating negation of loss points might be related. 
 \newline 




\end{document}


