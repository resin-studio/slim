\documentclass{beamer}

\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{listings}
\usepackage[utf8]{inputenc}


\lstset{
    identifierstyle=\color{violet},
    % textcolor=blue,
    % keywordstyle=\color{blue},
    keywordstyle=\text,
    basicstyle=\ttfamily,
    mathescape=true,
    showspaces=false,
    morekeywords={let, fix}
}

\title{Program synthesis with relational types}
\author{Thomas Logan}
\date{18 November 2022}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Problem: synthesize a program}

  \begin{itemize}
  \item initial program with holes 
  \item initial specification  
  \item optional annotations  
  \item unprescribed static bounds
  \item comparable to popular scripting languages
    \begin{itemize}
    \item .e.g. Python, JavaScript  
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Unprescribed static bounds in Python}

  \begin{lstlisting}[language=Python]
  def foo(x):
      if isinstance(x, int):
          return x + 1 
      else:
        return x + "abc"
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Prescribed static bounds with datatypes}

  \begin{lstlisting}[language=ML]
  datatype int_or_str = 
      Int of int | 
      Str of string

  fun foo(Int x) = x + 1
    | foo(Str x) = x ^ "abc"
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Specification}
  \begin{itemize}
  \item Types as specification 
  \item Propagation of types   
    \begin{itemize}
    \item Expected types decomposed to locally guide at holes and leaf terms   
    \item Actual types synthesized in case annotations missing 
    \end{itemize}

  \item Expressive types    
    \begin{itemize}
    \item Subtyping since static bounds unprescribed 
    \item Union and Intersection types to expand and narrow static bounds 
    \item Precise relations to guide effectively   
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Propagation: down}

  \begin{lstlisting}
  $\lambda$ n : nat $\Rightarrow$
    let first = ($\lambda$ (x,y) : (str $\times$ str) $\Rightarrow$ x) .
    first (n, _) 

    
    (n, _) : str $\times$ str

    n : str   _ : str  

    nat $\leq$ str 
    

  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Propagation: up}

  \begin{lstlisting}

  upper : str -> str
  $\hdots$
  $\lambda$ x $\Rightarrow$ $\lambda$ y $\Rightarrow$
    #cons(upper x,#cons(upper y,#nil()))


  str $\rightarrow$ str $\rightarrow$
    #cons(str $\times$ #cons(str $\times$ #nil$\diamondsuit$))

  \end{lstlisting}

\end{frame}


\begin{frame}[fragile]
  \frametitle{Expressive: widening}

  \begin{lstlisting}
  ($\lambda$ pair : $\forall$ $\alpha$ . $\alpha$ $\rightarrow$ $\alpha$ $\rightarrow$ ($\alpha$ $\times$ $\alpha$) $\Rightarrow$ 
  ($\lambda$ n : int $\Rightarrow$ ($\lambda$ s : str $\Rightarrow$ 
    pair n s
  )))
  \end{lstlisting}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Expressive: narrowing}

  \begin{lstlisting}
  ($\lambda$ i2n : int $\rightarrow$ nat $\Rightarrow$ 
  ($\lambda$ s2n : str $\rightarrow$ nat $\Rightarrow$ 
    $\lambda$ x $\Rightarrow$ (i2n x, s2n x)
  ))
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Expressive: relational record}

  \begin{lstlisting}[]
  let measurement : $\mu$ (nat $\times$ list) .
    #zero $\diamondsuit$ $\times$ #nil $\diamondsuit$ | 
    #succ nat $\times$ #cons (? $\times$ list)
  \end{lstlisting} 

\end{frame}

\begin{frame}[fragile]
  \frametitle{Expressive: relational record expanded}

  \begin{lstlisting}[]
  let measurement : 
  $\exists$ $\alpha$ . $\mu$ nat_and_list .
    #zero $\diamondsuit$ $\times$ #nil $\diamondsuit$ | 
    $\exists$ nat list :: 
      (nat $\times$ list) $\leq$ nat_and_list .
      #succ nat $\times$ #cons ($\alpha$ $\times$ list)
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Expressive: relational record comparison (Synquid)}

  \begin{lstlisting}[keywords={termination, measure, data, where}]
  termination measure len :: List $\beta$ $\rightarrow$ Nat 
  data List $\beta$ where
    Nil :: {v: List $\beta$ | len v = 0}
    Cons :: $\beta$ $\rightarrow$ xs: List $\beta$ $\rightarrow$ 
      {v: List $\beta$ | len v = len xs + 1}

  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Expressive: relational function}

  \begin{lstlisting}[]
  let replicate : 
  $\forall$ $\alpha$ . $\alpha$ $\rightarrow$ $\nu$ (nat $\rightarrow$ list) .
    #zero $\diamondsuit$ $\rightarrow$ #nil $\diamondsuit$ & 
    #succ nat $\rightarrow$ #cons ($\alpha$ $\times$ list)
  \end{lstlisting}


\end{frame}

\begin{frame}[fragile]

  \frametitle{Expressive: relational function expanded}

  \begin{lstlisting}[]
  let replicate : 
  $\forall$ $\alpha$ . $\alpha$ $\rightarrow$ $\nu$ nat_to_list .
    #zero $\diamondsuit$ $\rightarrow$ #nil $\diamondsuit$ & 
    $\forall$ nat list :: 
      nat_to_list $\leq$ (nat $\rightarrow$ list) .
      #succ nat $\rightarrow$ #cons ($\alpha$ $\times$ list)
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]

  \frametitle{Expressive: relational function comparison (Synquid)}

  \begin{lstlisting}[keywords={termination, measure, data, where}]
  replicate :: n:Nat $\rightarrow$ x:$\alpha$ $\rightarrow$ 
    {v: List $\alpha$ | len v = n}

  \end{lstlisting}

  \hfill
\end{frame}

\begin{frame}[fragile]
  \frametitle{Expressive: recursive pattern matching}
  \begin{lstlisting}[]
  let replicate = 
  $\lambda$ x $\Rightarrow$ fix ($\lambda$ self $\Rightarrow$
    $\lambda$ #zero () $\Rightarrow$ #nil () ;
    $\lambda$ #succ n $\Rightarrow$ #cons (x, self n)
  ) 
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Expressive: unification of nat}

  \begin{lstlisting}[]
  nat $\equiv$ $\mu$ nat .
    #zero $\diamondsuit$ | 
    #succ nat

  > #zero $\diamondsuit$ $\leq$ nat 
  < {$\cdot$} 

  > #succ #succ #zero $\diamondsuit$ $\leq$ nat 
  < {$\cdot$} 

  > #succ $\alpha$ $\leq$ nat 
  < {($\cdot$,$\alpha\mapsto$ $\mu$ $\beta$ .  #zero $\diamondsuit$ | #succ $\beta$)} 
  
  \end{lstlisting} 

\end{frame}



\end{document}