\documentclass{beamer}

\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{listings}
\usepackage[utf8]{inputenc}


\lstset{
    identifierstyle=\color{violet},
    % textcolor=blue,
    % keywordstyle=\color{blue},
    keywordstyle=\text,
    basicstyle=\ttfamily,
    mathescape=true,
    showspaces=false,
    morekeywords={let, fix}
}

\title{Program synthesis with relational types}
\author{Thomas Logan}
\date{18 November 2022}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Problem: synthesize a program}

  \begin{itemize}
  \item initial program with holes 
  \item initial specification  
  \item optional annotations  
  \item unprescribed static bounds
  \item comparable to popular scripting languages
    \begin{itemize}
    \item .e.g. Python, JavaScript  
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Unprescribed static bounds in Python}

  \begin{lstlisting}[language=Python]
  def foo(x):
      if isinstance(x, int):
          return x + 1 
      else:
        return x + "abc"
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Prescribed static bounds with datatypes}

  \begin{lstlisting}[language=ML]
  datatype int_or_str = 
      Int of int | 
      Str of string

  fun foo(Int x) = x + 1
    | foo(Str x) = x ^ "abc"
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Specification}
  \begin{itemize}
  \item Types as specification 
  \item Propagation of types   
    \begin{itemize}
    \item Expected types decomposed to locally guide at holes and leaf terms   
    \item Actual types synthesized in case annotations missing 
    \end{itemize}

  \item Expressive types    
    \begin{itemize}
    \item Subtyping since static bounds unprescribed 
    \item Union and Intersection types to expand and narrow static bounds 
    \item Precise relations to guide effectively   
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Propagation: down}

  \begin{lstlisting}
  $\lambda$ n : nat $\Rightarrow$
    let first = ($\lambda$ (x,y) : (str $\times$ str) $\Rightarrow$ x) .
    first (n, _) 

    
    (n, _) : str $\times$ str

    n : str   _ : str  

    nat $\leq$ str 
    

  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Propagation: up}

  \begin{lstlisting}

  upper : str -> str
  $\hdots$
  $\lambda$ x $\Rightarrow$ $\lambda$ y $\Rightarrow$
    #cons(upper x,#cons(upper y,#nil()))


  str $\rightarrow$ str $\rightarrow$
    #cons(str $\times$ #cons(str $\times$ #nil$\diamondsuit$))

  \end{lstlisting}

\end{frame}

\end{document}