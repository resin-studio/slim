% \documentclass{article}
% \documentclass[]{acmart}
\documentclass[sigplan,screen]{acmart}

\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{listings}
\lstset{
    identifierstyle=\color{blue},
    % textcolor=blue,
    % keywordstyle=\color{blue},
    % keywordstyle=\textbf,
    basicstyle=\ttfamily,
    mathescape=true,
    showspaces=false
}
\usepackage[utf8]{inputenc}
% \usepackage[T1]{fontenc}

\title{Type-guided synthesis for dynamically typed languages}
\author{Thomas Logan}
\date{October 2022}

\begin{document}

\maketitle
\section{Introduction}


\textbf{Dynamically typed} languages can make writing programs quick and easy 
because they don't require specifying static bounds on behavior.
Two of the most popular programming languages today, JavaScript and Python, 
are dynamically typed. 
JavaScript is the language of the web, while Python is the most popular choice
for data science and machine learning projects. 
Consider a Python program that operates on strings or integers. 

\begin{lstlisting}[language=Python]
def foo(x):
    if isinstance(x, int):
        return x + 1 
    elif isinstance(x, str): 
        return x + "abc"
\end{lstlisting}

\noindent The dynamically typed program avoids the extra step of associating terms with
static bounds as seen in ML-family languages using the datatype mechanism. 

\begin{lstlisting}[language=ML]
datatype int_or_str = 
    Int of int | 
    Str of string

fun foo(Int x) = x + 1
  | foo(Str x) = x ^ "abc"
\end{lstlisting}


Although dynamically typed languages already offer ease and efficiency for writing programs, 
this facility can be enhanced with \textbf{synthesis of programs} 
from surrounding context. 
This article presents a system that synthesizes terms from context 
in a dynamically typed language.
Synthesis of programs for a dynamically typed language introduces a fundamental tension. 
While dynamically typed programs benefit from a lack of static bounds, program synthesis
must be a terminating procedure driven by static bounds representing the goals of synthesis.   

\textbf{Types} have become the lingua franca of formal specification of static bounds.
Others have shown how various forms of specification, including examples, abstract values, 
pure propositions, and modal propositions, can be encoded as types.
Types have been used successfully for verifying programs, 
guiding program synthesis in ML-family languages, 
and guiding humans in dependently-typed interactive theorem proving. 

Dynamically, two interfaces may have the same correctness result for some inputs,
while differing on other inputs. \textbf{subtyping} is used to decide if a term's 
composition is statically invalid, maintaining semblance to dynamically typed programming,
while also adding safety with static behavior.

By \textbf{propagating} and decomposing types, 
it is possible to guide the synthesis of programs.
To maintain the spirit of dynamic types, type annotations must remain optional.
Previous work has demonstrated the utility of propagating types 
in theorem proving systems, local type checking, 
and synthesis of ML-family programs.

For example, in a program that extracts 
the first element of a pair of a particular type, 
it's possible to detect an error before knowing the second element.

to detect an error of a pairt of a   
\begin{lstlisting}
$\lambda$ n $\in$ nat $\Rightarrow$
  let first = ($\lambda$ (x,y) $\in$ (str $\times$ str) $\Rightarrow$ x) .
  first (n, _) 
\end{lstlisting}

\noindent The  applications' argument type \lstinline{(nat $\times$ ?)} 
is propagated and decomposed such that the subtyping constraint 
\lstinline{nat $\subseteq$ str} is decided. 

In order to have fine-grained control over where types are utilized or avoided, 
types may be composed of \textbf{dynamic types}, represented by "?" to indicate 
that any subterm corresponding to that portion of the type 
will not be subject to static constraints.

If type annotations are not available, then \textbf{types are inferred} from context. 
The actual type of a term can be inferred in an obvious way.  

\begin{lstlisting}

#cons("hello",#cons("world",#nil())) $\in$ 
#cons(str $\times$ #cons(str $\times$ #nil$\diamondsuit$))

\end{lstlisting}

To infer expected types, type inference techniques for ML-family languages 
are a good starting point.
ML-family type inference is sound, because an ML term is 
intrinsically associated with a static bound in accordance with ML's datatype mechanism.
Terms in dynamically typed languages are not intrinsically associated with a principal type. 
Type inference for dynamically typed languages cannot be sound without greatly violating the 
liberal reuse of terms afforded by dynamic types. 

Thus, it is necessary to devise a method of type inference that is unsound, 
yet still provides sufficient information to guide efficient program synthesis.
Additionally, despite being unsound, it should be able to prune/reject 
a significant portion of bad programs. 
It may reject good programs, but only if it can infer a static type.

In parametric types where a generic input type must be the same as a generic output type,
The dynamic nature of terms is at odds with inferring types.

\begin{lstlisting}
($\lambda$ pair $\in$ $\forall$ $\alpha$ . $\alpha$ $\rightarrow$ $\alpha$ $\rightarrow$ ($\alpha$ $\times$ $\alpha$) $\Rightarrow$ 
($\lambda$ n $\in$ int $\Rightarrow$ ($\lambda$ s $\in$ str $\Rightarrow$ 
  pair n s
)))
\end{lstlisting}

\noindent These generic types can be specialized based on the terms that are witnessed as inputs. 
Since a principal type cannot be inferred in dynamically typed languages, 
The parameter type must accommodate types of unforeseen arguments, 
while the return type should be \textbf{widened} but restricted 
to previously seen arguments.
This system tackles the tension in these goals by combining the union combinator  
with the dynamic type. 

Once \lstinline{pair} is applied to an integer its generic type is specialized to 
\lstinline{int $\cup$ ?}, 
in which union with the dynamic type behaves like the top type $\top$, 
accommodating receiving a string as a the subsequent input.
Thus, the generic type is specialized to \lstinline{int $\cup$ str $\cup$ ?}.
The result type for \lstinline{pair n s} ends up as 
\lstinline{(int $\cup$ string) $\times$ (int $\cup$ string)}. 
The semantics of union with the dynamic type result in the dynamic type 
falling away for actual types.

In functions where a parameter has an unknown type and that parameter is 
internally used as an argument to an application, the dynamic nature of terms  
adds some complications to type inference.

\begin{lstlisting}
($\lambda$ i2n $\in$ int $\rightarrow$ nat $\Rightarrow$ 
($\lambda$ s2n $\in$ str $\rightarrow$ nat $\Rightarrow$ 
  $\lambda$ x $\Rightarrow$ (i2n x, s2n x)
))

\end{lstlisting}

The argument type must avail itself to internal parameter types of unforeseen compositions,
while the external parameter type should be \textbf{narrowed} and restricted 
to the internal parameter types of previously seen compositions.
Once \lstinline{i2n} is applied to \lstinline{x}, 
the type for \lstinline{x} is specialized to \lstinline{int $\cap$ ?}, 
in which intersection with the dynamic type behaves like the bottom type $\bot$,
availing itself to be used in subsequent applications. 
Thus, the dynamic type is inferred to be \lstinline{int $\cap$ str $\cap$ ?}.
The external parameter type for ends up as \lstinline{int $\cap$ str}. 
The semantics of intersection with the dynamic type result in the dynamic type
falling away for expected types.



In order to efficiently guide program synthesis, 
types must be able to \textbf{express} fairly precise information. 
The system presented here offers types with 
expressivity comparable to typical decidable predicate logics. 
For example, the types are expressive enough to precisely specify
a function that takes a natural number \lstinline{n} 
and an element \lstinline{x}, 
and returns list of n elements.

\begin{lstlisting}[]
let replicate $\in$ 
$\forall$ $\alpha$ . $\alpha$ $\rightarrow$ $\mu$ nat_to_list .
  #zero $\diamondsuit$ $\rightarrow$ #nil $\diamondsuit$ $\cap$ 
  $\forall$ nat list | 
    (nat $\rightarrow$ list) $\subseteq$ nat_to_list .
    #succ nat $\rightarrow$ #cons ($\alpha$ $\times$ list)
\end{lstlisting}

\noindent Correspondingly, types can also specify a pair of a list and its length.

\begin{lstlisting}[]
let measurment $\in$ 
$\exists$ $\alpha$ . $\mu$ nat_and_list .
  #zero $\diamondsuit$ $\times$ #nil $\diamondsuit$ $\cup$ 
  $\exists$ nat list | 
    (nat $\times$ list) $\subseteq$ nat_and_list .
    #succ nat $\times$ #cons ($\alpha$ $\times$ list)
\end{lstlisting}



\section{Overview}

\section{Technical Details}

\section{Evaluation}

\section{Related work}

\section*{Notes}

Novel contributions: This system is the first to have:
\begin{enumerate}
  \item program synthesis from partial programs with missing annotations  
  \item algorithmic subsumption allows simple subtyping rule with dynamic type
    \begin{enumerate}
      \item subtyping can having a dynamic type on either side without risk of   
        a subsumption rule accepting any arbitrary type
    \end{enumerate}
  \item type unification without principal type schemes: 
    \begin{enumerate}
      \item lenient (but unsound) static type inference
      \item expanding type info with union and intersection and dynamic type
      \item subtyping rules for intersection and union 
    \end{enumerate}
  \item full type synthesis with full type propagation (for all rules)
  \item interleaving type constraint generation and solving with dynamic type 
  \item an expressive predicate logic 
    based on intersection, union, and recursive types;
    without dependent types
  \item a type system that meets with all three properties:
    \begin{enumerate}
      \item allows dynamic type 
      \item sound modulo absence of dynamic type 
        or static type union/intersect with dynamic
      \item types behave either leniently or strict depending on usage as actual type or expected type
    \end{enumerate}
\end{enumerate}

How gradually typed inference typically works:
\begin{enumerate}
  \item infer either a strict static type or a dynamic type
  \item let annotations implicitly guide the usage of static vs dynamic checks 
\end{enumerate}


There exists work on type inference for gradually typed programs.
To the best of my knowledge, they are all sound and complete.
This notion results in the inference being unsound.
Other gradual type inference systems separate 
generating constraints from solving constraints.
Our system toggles between generating and solving constraints incrementally.
Other gradual typing systems use the dynamic type "?" to indicate 
that dynamic checks should be used.
They do not contain the idea of using intersection and union to keep types open.
Gradual typing systems separate subtyping from the relation 
between dynamic to static types to avoid all terms typing via the subsumption rule.


\subsection*{references}
\begin{enumerate}
\item Refinement types for ML by Tim Freeman and Frank Pfenning 
\item Refinement types as proof irrelevance by William Lovas and Frank Pfenning 
\item Local type inference by Benjamin C. Pierce and David N. Turner
\item Liquid types - \url{http://goto.ucsd.edu/~rjhala/papers/liquid_types.pdf}
\item Program synthesis from polymorphic refinement types by Nadia Polikarpova, Ivan Kuraj, and Armando Solar-Lezama
\item Example-directed synthesis: a type-theoretic interpretation by Frankle, Osera, Walker, and Zdancewic
\item Gradual typing for functional languages by Jeremy G. Siek and Walid Taha 
\item Gradual typing for functional languages by Jeremy G. Siek and Walid Taha 
\item Gradual typing for objects by Jeremy G. Siek and Walid Taha 
\item Gradual typing with unification-based inference by Siek and Manish Vachharajani 
\item Dynamic Type Inference for Gradual Hindleyâ€“Milner Typing - \url{https://dl.acm.org/doi/pdf/10.1145/3290331}
\item Principal type schemes for gradual programs - \url{https://www.cs.ubc.ca/~rxg/ptsgp.pdf}
\item Gradual Liquid Type Inference - \url{https://arxiv.org/pdf/1807.02132.pdf}
\item Gradual typing with union and intersection types - \url{https://dl.acm.org/doi/pdf/10.1145/3110285}
\item Gradual typing: a new perspective - unions, intersections, dynamic type, and type inference - \url{https://www.irif.fr/~gc/papers/popl19.pdf}
\item Gradual refinement types (via abstract interpretation) - \url{https://pleiad.cl/papers/2017/lehmannTanter-popl2017.pdf}
\item Consistent subtyping for all - \url{https://xnning.github.io/papers/consistent-subtyping-for-all-toplas.pdf}
\item Polymorphic functions with set-theoretic types, part 1 - \url{https://www.irif.fr/~gc/papers/polydeuces-part1.pdf}
\item Polymorphic functions with set-theoretic types, part 2 - \url{https://www.irif.fr/~gc/papers/polydeuces-part2.pdf}


\end{enumerate}



\end{document}